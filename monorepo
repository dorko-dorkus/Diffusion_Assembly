# assembly_diffusion/__init__.py
# Adds PyTorch Dataset + DataLoader for QM9 CHON subset.

import os
import math
import random
import urllib.request
import tarfile
import torch
import torch.nn as nn
from torch.utils.data import Dataset, DataLoader
from rdkit import Chem
from rdkit.Chem import SanitizeMol

# -------------------
# Molecule Graph Representation
# -------------------
class MoleculeGraph:
    def __init__(self, atoms, bonds):
        self.atoms = atoms
        self.bonds = bonds

    def copy(self):
        return MoleculeGraph(self.atoms.copy(), self.bonds.clone())

    def to_rdkit(self):
        mol = Chem.RWMol()
        atom_map = [mol.AddAtom(Chem.Atom(a)) for a in self.atoms]
        for i in range(len(self.atoms)):
            for j in range(i+1, len(self.atoms)):
                b = int(self.bonds[i, j])
                if b > 0:
                    mol.AddBond(atom_map[i], atom_map[j], [Chem.BondType.SINGLE, Chem.BondType.DOUBLE][b-1])
        return mol

    def is_valid(self):
        try:
            mol = self.to_rdkit()
            SanitizeMol(mol)
            return True
        except:
            return False

    def canonical_smiles(self):
        return Chem.MolToSmiles(self.to_rdkit(), canonical=True)

# -------------------
# Feasibility Masking
# -------------------
class FeasibilityMask:
    def mask_edits(self, x):
        mask = {}
        for i in range(len(x.atoms)):
            for j in range(i+1, len(x.atoms)):
                for b in [0, 1, 2]:
                    mask[(i, j, b)] = 1 if self.valence_ok(x, i, j, b) else 0
        mask['STOP'] = 1
        return mask

    def valence_ok(self, x, i, j, b):
        test = x.copy()
        test.bonds[i, j] = b
        test.bonds[j, i] = b
        return test.is_valid()

# -------------------
# Forward Kernel
# -------------------
class ForwardKernel:
    def __init__(self, beta0=0.1, T=10):
        self.beta0 = beta0
        self.T = T

    def alpha(self, t):
        return math.exp(-self.beta0 * t / self.T)

    def sample_xt(self, x0, t):
        x = x0.copy()
        for i in range(len(x.atoms)):
            for j in range(i+1, len(x.atoms)):
                if x.bonds[i, j] > 0 and random.random() > self.alpha(t):
                    x.bonds[i, j] = x.bonds[j, i] = 0
        return x

# -------------------
# Simple GNN Backbone
# -------------------
class GNNBackbone(nn.Module):
    def __init__(self, node_dim=16):
        super().__init__()
        self.node_fc = nn.Linear(node_dim, node_dim)

    def forward(self, x, t):
        h_nodes = torch.randn(len(x.atoms), 16)
        h_edges = torch.randn(len(x.atoms), len(x.atoms), 4)
        return h_nodes, h_edges

# -------------------
# Reverse Policy
# -------------------
class ReversePolicy(nn.Module):
    def __init__(self, backbone):
        super().__init__()
        self.backbone = backbone
        self.stop_head = nn.Linear(16, 1)

    def logits(self, x, t, mask):
        h_nodes, h_edges = self.backbone(x, t)
        e_scores = torch.randn(len(mask)-1)
        stop_score = self.stop_head(h_nodes.mean(dim=0))
        return torch.cat([e_scores, stop_score.flatten()])

# -------------------
# Sampler
# -------------------
class Sampler:
    def __init__(self, policy, mask):
        self.policy = policy
        self.masker = mask

    def sample(self, T, x_init):
        x = x_init.copy()
        for t in range(T, 0, -1):
            mask = self.masker.mask_edits(x)
            logits = self.policy.logits(x, t, mask)
            e = random.choice(list(mask.keys()))
            if e == 'STOP':
                break
            i, j, b = e
            x.bonds[i, j] = x.bonds[j, i] = b
        return x

# -------------------
# QM9 CHON Loader with auto-download
# -------------------

def download_qm9():
    url = "https://deepchemdata.s3-us-west-1.amazonaws.com/datasets/gdb9.tar.gz"
    os.makedirs("qm9_raw", exist_ok=True)
    archive_path = "qm9_raw/gdb9.tar.gz"
    if not os.path.exists(archive_path):
        print("Downloading QM9 dataset...")
        urllib.request.urlretrieve(url, archive_path)
        print("Download complete.")
        with tarfile.open(archive_path, "r:gz") as tar:
            tar.extractall(path="qm9_raw")
            print("Extraction complete.")

def load_qm9_chon(max_heavy=12):
    from rdkit.Chem import rdmolfiles
    if not os.path.exists("qm9_raw/gdb9.sdf"):
        download_qm9()
    mols = []
    suppl = rdmolfiles.SDMolSupplier("qm9_raw/gdb9.sdf")
    for mol in suppl:
        if mol is None:
            continue
        atoms = [a.GetSymbol() for a in mol.GetAtoms()]
        if all(a in ['C', 'H', 'O', 'N'] for a in atoms) and sum(a != 'H' for a in atoms) <= max_heavy:
            bonds = torch.zeros((len(atoms), len(atoms)))
            for bond in mol.GetBonds():
                i, j = bond.GetBeginAtomIdx(), bond.GetEndAtomIdx()
                order = int(bond.GetBondTypeAsDouble())
                bonds[i, j] = bonds[j, i] = order
            mols.append(MoleculeGraph(atoms, bonds))
    return mols

# -------------------
# PyTorch Dataset for QM9 CHON
# -------------------
class QM9CHON_Dataset(Dataset):
    def __init__(self, max_heavy=12):
        self.data = load_qm9_chon(max_heavy)
    def __len__(self):
        return len(self.data)
    def __getitem__(self, idx):
        return self.data[idx]

# -------------------
# Example Training Loop
# -------------------
def train_epoch(loader, kernel, policy, mask):
    for x0 in loader:
        t = random.randint(1, kernel.T)
        xt = kernel.sample_xt(x0, t)
        mask_ = mask.mask_edits(xt)
        logits = policy.logits(xt, t, mask_)
        loss = logits.sum() * 0  # Placeholder
        loss.backward()

# -------------------
# Utility: DataLoader factory
# -------------------
def get_dataloader(batch_size=32, max_heavy=12):
    dataset = QM9CHON_Dataset(max_heavy)
    return DataLoader(dataset, batch_size=batch_size, shuffle=True, collate_fn=lambda x: x)
